package taskone;

import java.util.Arrays;
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
/**
 * Given a collection of match-cars that lie in a grid, 
 * generate the network of tunnels that will require the 
 * least work the reach every car.
 * @author Tony Jiang, Devin Sun, Suyi Liu
 *
 */
public final class BackyardDig {

    /**
     * Shutup Checkstyle..
     */
    private BackyardDig() {   
        
    }
    
    /**
     * Main method.
     * @param args First argument: Input file containing 
     * grid size and car locations based on edges and respective weights.
     */
    public static void main(String[] args) {
        File inputFile = new File(args[0]);
        String outputFile = args[1];
        
        Scanner scan;
        
        int cols = 0;
        
        
        AdjacencyList al = new AdjacencyList(inputFile);
        System.out.println(al.getNumVtcs());
        try {
            //Grab rows and columns from input
            scan = new Scanner(inputFile);
            scan.nextInt();
            cols = scan.nextInt();
            
            //Skip Empty Line
            scan.nextLine();
            scan.nextLine();
            scan.close();
            
        } catch (FileNotFoundException e1) {
            e1.printStackTrace();
            System.out.println("Error: File not found");
        }
        
        // DIJKSTRA'S ALGORITHM
        int[] dist = new int[al.getSize()];
        Arrays.fill(dist, Integer.MAX_VALUE);
        int[] prev = new int[al.getSize()];
        boolean[] found = new boolean[al.getSize()];
        
        int startVtx = al.array[0].getFirst().name;
        dist[startVtx] = 0;
        int numVtcs = al.getNumVtcs();
        int i;
        int minVtx = startVtx;
        
        for (int k = 0; k < numVtcs; k++) {
            int min = Integer.MAX_VALUE;
            for (i = 0; i < numVtcs; i++) {
                if (dist[i] < min && !found[i]) {
                    min = dist[i];
                    minVtx = i;
                }
            }
            found[minVtx] = true;
            
            for (int c = 0; c < al.array[minVtx].size(); c++) {
                
                int cost = al.array[minVtx].get(c).weight;
                int destVtx = al.array[minVtx].get(c).name;
                
                if (dist[minVtx] + cost < dist[destVtx]) {
                    dist[destVtx] = dist[minVtx] + cost;
                    prev[destVtx] = minVtx;
                }
            }
        }

        try {
            PrintWriter pr = new PrintWriter(outputFile, "UTF-8");
            
            //Caclulate Totalwork.
            int totalWork = calculateWork(prev, dist, startVtx);
            pr.println(totalWork);
            pr.println();
            
            //Print all paths that produce the least work to reach the cars.
            printPaths(pr, prev, startVtx, cols);
            
            pr.close();
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } 
        
    }
    
    /**
     * Calculate the total work.
     * @param prev the array of previous verices generated by Dijkstra's.
     * @param dist the array containing the minimal cost to get from startVtx
     * to each other vertex in the graph.
     * @param startVtx the start vertex.
     * @return an integer containing the total work
     * necessary to create the graph.
     */
    public static int calculateWork(int[] prev, int[] dist, int startVtx) {
        int totalWork = 0;
        for (int j = 0; j < dist.length; j++) {
            int index = j;
            int edgenum = 0;
            while (!(index == startVtx)) {
                if (edgenum == 0) {
                    totalWork += dist[index];
                    
                } else if (edgenum == 1) {
                    totalWork -= dist[index];
                }
                index = prev[index];
                edgenum++;
            }
        }
        return totalWork;
    }
    
    /**
     * Print the edges necessary to create a graph from
     * a start vertex with the least amount of work.
     * @param pr Printwriter to print to output
     * @param prev Previous array generated by Djikstra's
     * @param startVtx starting vertex used in Djikstra's
     * @param cols number of columns in grid
     */
    public static void printPaths(PrintWriter pr, 
            int[] prev, int startVtx, int cols) {
        for (int k = 0; k < prev.length; k++) {
            if (!(k == startVtx)) {
                int startx = k / cols;
                int starty = k % cols;
                
                int endx = prev[k] / cols;
                int endy = prev[k] % cols;
                
                pr.println("(" + startx + "," + starty + ") (" + endx
                        + "," + endy + ")");
            }
        }
    }

}
