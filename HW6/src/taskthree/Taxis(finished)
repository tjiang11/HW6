import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.PriorityQueue;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class.
 * @author Suyi
 *
 */
    
class Location implements Comparable<Location> {
    
    /**
     * The name of the location.
     */
	
    public String name;
    
    /**
     * Array of adjacent locations.
     */
    public ArrayList<Edge> adjacencies = new ArrayList<Edge>();
    
    /**
     * The minimum distance from the location to a certain location.
     */
    public double minDistance = Double.POSITIVE_INFINITY;
    
    /**
     * Its previous location in the shortest path.
     */
    public Location previous;
    
    /**
     * Construct a location.
     * @param paraName  name of the location
     */
    public Location(String paraName) { 
        this.name = paraName; 
    }
    
    /**
     * Returns the name of the location.
     * @return the name
     */
    public String toString() { 
       return this.name; 
    }
    
    
    
    /**
     * Check if there exists a smaller distance.
     * @param other another distance of another location
     * @return if there exists a smaller distance
     */
    public int compareTo(Location other) {
        return Double.compare(minDistance, other.minDistance);
    }
    
    
}   

/**
 * The roads between two locations.
 * @author Suyi
 *
 */
class Edge {
    
    /**
     * The target location.
     */
    public Location target;
    
    /**
     * The cost from the target to the previous location.
     */
    public double weight;
    
    /**
     * Constructs the edge.
     * @param paraTarget   the new location
     * @param paraWeight   the cost on the road from the previous location
     */
    public Edge(Location paraTarget, double paraWeight) { 
       
        this.target = paraTarget; 
        
        this.weight = paraWeight; 
    }
    
    @Override
    public String toString() {
    	return "(" + target + ", " + weight + ")";
    }
}



 
/**
 * The taxis class.
 * @author Suyi
 *
 */
public final class Taxis {
	
    
    /**
     * Shutup Checkstyle.
     */
    private Taxis() {
        
    }
    private static int locationnumber = 0;

    private static int connectionnumber = 0;
    
    private static int drivernumber = 0;
    
    /**
     * Computes the shortest paths to a location using Dijkstra's algorithm.
     * @param source  the original location
     */
    
    public static void computePaths(Location source) {
        source.minDistance = 0.;
        PriorityQueue<Location> vertexQueue = new PriorityQueue<Location>();
        vertexQueue.add(source);
        while (!vertexQueue.isEmpty()) {
            Location u = vertexQueue.poll();
//            System.out.println("size"+ u.adjacencies.size());
            for (Edge e : u.adjacencies) {
//            	System.out.println("Work2");
                Location v = e.target;
                double weight = e.weight;
                double distanceThroughU = u.minDistance + weight;
                if (distanceThroughU < v.minDistance) {
                    vertexQueue.remove(v);
                    v.minDistance = distanceThroughU;
                    v.previous = u;
                    vertexQueue.add(v);
                }
            }
        }
    }

    /**
     * The list representing the shortest path.
     * @param target  the target location from the original one
     * @return  the arraylist of the shortest path
     */
    public static List<Location> getShortestPathTo(Location target) {
        List<Location> path = new ArrayList<Location>();
        for (Location vertex = target; vertex != null;
                vertex = vertex.previous) {
            path.add(vertex);
        }
//        Collections.reverse(path);
        return path;
    }
    
    public static String getPathTo(Location vertex) {
        String path = "";

            path = "(" + vertex.toString() + ", " + vertex.previous.toString() + ")";

//        Collections.reverse(path);
        return path;
    }
    
    public static ArrayList<Location> locationsFromFile(String fileName) {
    	try{
    	ArrayList<Location> locations1 = new ArrayList<Location>();
		Scanner fileIn = new Scanner(new FileReader(fileName));
		while (fileIn.hasNextLine()) {
			String name = fileIn.nextLine().trim();
			if (name.isEmpty()) continue;
			locations1.add(new Location(name));
			locationnumber++;
		}
		fileIn.close();
    	return locations1;
    	} catch (FileNotFoundException e) {
    		System.err.println("File not found");
    		return null;
    	}
    }
    
	public static void printLocations(ArrayList<Location> locationlist) {
		for (int i = 0; i < locationlist.size(); i++) {
			int n = i + 1;
			System.out.println("      " + n + " " + locationlist.get(i));
		}
	}
    
    public static ArrayList<Location> createMap(ArrayList<Location> locations, String connectionFileName) {
    	try {
    		Scanner connIn = new Scanner(new FileReader(connectionFileName));
    		while (connIn.hasNextLine()) {
    			String edgeInfo = connIn.nextLine();
    			String pattern = "\\((.*), (.*)\\)\\s*(\\d*)";
    			Pattern expr = Pattern.compile(pattern);
    			Matcher matcher = expr.matcher(edgeInfo);
    			if (matcher.find()) {
    				String streetName1 = matcher.group(1).trim();
    				String streetName2 = matcher.group(2).trim();
    				int distance = Integer.parseInt(matcher.group(3));
    				Location loc1 = null, loc2 = null;
    				for (int i = 0; i < locations.size(); i++) {
    					if (locations.get(i).name.equals(streetName1)) {
    						loc1 = locations.get(i);
    					} else if (locations.get(i).name.equals(streetName2)) {
    						loc2 = locations.get(i);
    					}
    				}
    				if (loc1 == null || loc2 == null) {
    					System.err.println("Not found: " + streetName1 + ", " + streetName2 + ", " + distance);
    				}
    				loc1.adjacencies.add(new Edge(loc2, distance));
    				loc2.adjacencies.add(new Edge(loc1, distance));
    				connectionnumber++;
    			}
    		}
    		connIn.close();
    		return locations;
    	} catch (FileNotFoundException e) {
    		System.err.println("File not found");
    		return null;
    	}
    }

   // public static DriversList 
    
    public static void countDriverNumbers(String driversFilename) {
    	try {
    	Scanner fileIn = new Scanner(new FileReader(driversFilename));
    	while (fileIn.hasNext()) {
            fileIn.nextInt();
            fileIn.nextLine().trim();
			drivernumber++;
		}
		fileIn.close(); 
    	} catch  (FileNotFoundException e) {
    		System.err.println("File not found");
    	}
    }
    
	public static DriversPq createDrivers(String driversFileName, Location v, ArrayList<Location> locations ,ArrayList<Location> connections) {
		try {
	    computePaths(v);
		DriversPq drivers = new DriversPq();
		Scanner fileIn = new Scanner(new FileReader(driversFileName));
		Location driverspot;
		Double driverfrompickup;
		while (fileIn.hasNext()) {
			int driverid = fileIn.nextInt();
			String driverlocation = fileIn.nextLine().trim();
			for (int i = 0; i < locations.size(); i++) {
			    if (locations.get(i).name.equals(driverlocation)) {
				    driverspot = locations.get(i);
				    driverfrompickup = driverspot.minDistance;
				    drivers.insert(driverfrompickup, driverid, driverlocation);
			    }
			}
//			drivernumber++;
//			System.out.println(driverid);
//			System.out.println(driverlocation);
		}
		fileIn.close();
		return drivers;
		} catch  (FileNotFoundException e) {
    		System.err.println("File not found");
    		return null;
    	}
	}
	
	

	
    /**
     * Main method.
     * @param args   hmmmmm
     */
    public static void main(String[] args) {
    	Scanner kb = new Scanner(System.in);
        System.out.println("Welcome!");
        System.out.println();
        String numDrivers = args[0];
        String locationname = args[1];
        String connectionname = args[2];
        String driversname = args[3];
        

//    	Location[] vertices = { v0, v1, v2, v3, v4 }; 	    
//            computePaths(v0);
//            for (Location v : vertices)
//    	{
//    	    System.out.println("Distance to " + v + ": " + v.minDistance);
//    	    List<Location> path = getShortestPathTo(v);
//    	    System.out.println("Path: " + path);
//    	}
        ArrayList<Location> locations = Taxis.locationsFromFile(locationname);
        
        countDriverNumbers(driversname);
  
        System.out.println("Collecting map locations from " + locationname + "...");
        System.out.println( locationnumber + " locations input.");
        System.out.println();
        ArrayList<Location> locs = Taxis.createMap(locations, connectionname);
        System.out.println("Collecting map connections from " + connectionname + "...");
        System.out.println( connectionnumber + " connections input.");
        System.out.println();
        System.out.println("Collecting map connections from " + driversname + "...");
        System.out.println( drivernumber + " drivers input.");
        System.out.println();
        
        System.out.println("Map locations are: ");
        System.out.println();
        printLocations(locations);
        System.out.println();
        
        System.out.println("Enter number of recent client pickup request location: ");
        int pickup = kb.nextInt();
        Location pickuplocation = locations.get(pickup - 1);
        
        
        DriversPq drivers = Taxis.createDrivers(driversname, pickuplocation, locations, locs);
        
        int numberofdrivers = Integer.parseInt(numDrivers);
        System.out.println("The " + numberofdrivers + " drivers to alert about this pickup are: ");
        System.out.println();
        for (int i = 1; i <= numberofdrivers; i++) {
        	System.out.println(drivers.findMin().getId() + " at " + drivers.deleteMin().getAddress());
//        	drivers.deleteMin();
//        	System.out.println(drivers.array[i]);
        }
        
//        for (Location v : locations) {
//        System.out.println("Distance to " + v + ": " + v.minDistance);
//        }
        System.out.println();
        System.out.println("Enter the ID number of the driver who responded: ");
        int idnumber = kb.nextInt();
        System.out.println();
        DriversPq driversnew = Taxis.createDrivers(driversname, pickuplocation, locations, locs);
        for (int i = 1; i <= driversnew.size; i++) {
		    if (driversnew.array[i].getId() == idnumber) {
		    	 String addr = driversnew.array[i].getAddress();
		    	 Double time = driversnew.array[i].getKey();
		    	 for (int j = 0; j < locations.size(); j++) {
					    if (locations.get(j).name.equals(addr)) {
						    Location spot = locations.get(j);
						    List<Location> path = getShortestPathTo(spot);
						    System.out.println("The recommended route for driver " + idnumber + " is: ");
//						    System.out.println("          " + path);
//						    System.out.println("         Expected total time: " + time + " minutes.");
						    while(spot.previous != null) {
                               System.out.println("       " + getPathTo(spot));
                               spot = spot.previous;
						    }
						    System.out.println("      Expected total time: " + time + " minutes.");
					    }
					}
		    }
		}
        
        
//        for (Location loc : locs) {
//        	System.out.println(loc.name + "={");
//        	for (Edge e : loc.adjacencies) {
//        		System.out.print(e + ",");
//        	}
//        	System.out.println("}");
//        }
//        

    } 
 
}
