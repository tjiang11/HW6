    import java.util.PriorityQueue;
    import java.util.List;
    import java.util.ArrayList;
    import java.util.Collections;

/**
 * Class.
 * @author Suyi
 *
 */
    
class Location implements Comparable<Location> {
    
    /**
     * The name of the location.
     */
    public String name;
    
    /**
     * Array of adjacent locations.
     */
    public Edge[] adjacencies;
    
    /**
     * The minimum distance from the location to a certain location.
     */
    public double minDistance = Double.POSITIVE_INFINITY;
    
    /**
     * Its previous location in the shortest path.
     */
    public Location previous;
    
    /**
     * Construct a location.
     * @param paraName  name of the location
     */
    public Location(String paraName) { 
        this.name = paraName; 
    }
    
    /**
     * Returns the name of the location.
     * @return the name
     */
    public String toString() { 
        return this.name; 
    }
    
    /**
     * Check if there exists a smaller distance.
     * @param other another distance of another location
     * @return if there exists a smaller distance
     */
    public int compareTo(Location other) {
        return Double.compare(minDistance, other.minDistance);
    }
}   

/**
 * The roads between two locations.
 * @author Suyi
 *
 */
class Edge {
    
    /**
     * The target location.
     */
    public Location target;
    
    /**
     * The cost from the target to the previous location.
     */
    public double weight;
    
    /**
     * Constructs the edge.
     * @param paraTarget   the new location
     * @param paraWeight   the cost on the road from the previous location
     */
    public Edge(Location paraTarget, double paraWeight) { 
       
        this.target = paraTarget; 
        
        this.weight = paraWeight; 
    }
}
 
/**
 * The taxis class.
 * @author Suyi
 *
 */
public final class Taxis {
    
    /**
     * Shutup Checkstyle.
     */
    private Taxis() {
        
    }

    /**
     * Computes the shortest paths to a location using Dijkstra's algorithm.
     * @param source  the original location
     */
    public static void computePaths(Location source) {
        source.minDistance = 0.;
        PriorityQueue<Location> vertexQueue = new PriorityQueue<Location>();
        vertexQueue.add(source);

        while (!vertexQueue.isEmpty()) {
            Location u = vertexQueue.poll();
            for (Edge e : u.adjacencies) {
                Location v = e.target;
                double weight = e.weight;
                double distanceThroughU = u.minDistance + weight;
                if (distanceThroughU < v.minDistance) {
                    vertexQueue.remove(v);
                    v.minDistance = distanceThroughU;
                    v.previous = u;
                    vertexQueue.add(v);
                }
            }
        }
    }

    /**
     * The list representing the shortest path.
     * @param target  the target location from the original one
     * @return  the arraylist of the shortest path
     */
    public static List<Location> getShortestPathTo(Location target) {
        List<Location> path = new ArrayList<Location>();
        for (Location vertex = target; vertex != null;
                vertex = vertex.previous) {
            path.add(vertex);
        }
        Collections.reverse(path);
        return path;
    }

    /**
     * Main method.
     * @param args   hmmmmm
     */
    public static void main(String[] args) {
        System.out.println("Welcome!");
//        String numDrivers = args[0];
//            
//        AdjacencyListRoad roadMap = 
//                    new AdjacencyListRoad(new File(args[1]));
//        roadMap.importConnections(new File(args[2]));
           
    	Location v0 = new Location("Redvile");
    	Location v1 = new Location("Blueville");
    	Location v2 = new Location("Greenville");
    	Location v3 = new Location("Orangeville");
    	Location v4 = new Location("Purpleville");

    	v0.adjacencies = new Edge[]{ new Edge(v1, 5),
    	                             new Edge(v2, 10),
                                   new Edge(v3, 8) };
    	v1.adjacencies = new Edge[]{ new Edge(v0, 5),
    	                             new Edge(v2, 3),
    	                             new Edge(v4, 7) };
    	v2.adjacencies = new Edge[]{ new Edge(v0, 10),
                                   new Edge(v1, 3) };
    	v3.adjacencies = new Edge[]{ new Edge(v0, 8),
    	                             new Edge(v4, 2) };
    	v4.adjacencies = new Edge[]{ new Edge(v1, 7),
                                   new Edge(v3, 2) };
    	
    	Location[] vertices = { v0, v1, v2, v3, v4 }; 	    
            computePaths(v0);
            for (Location v : vertices)
    	{
    	    System.out.println("Distance to " + v + ": " + v.minDistance);
    	    List<Location> path = getShortestPathTo(v);
    	    System.out.println("Path: " + path);
    	}
    } 
 
}
